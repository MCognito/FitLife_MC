import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';
import 'package:mockito/annotations.dart';
import 'package:fitlife/features/authentication/view/pages/sign_up_page.dart';
import 'package:fitlife/features/authentication/service/auth_service.dart';
import 'package:fitlife/features/authentication/viewmodel/auth_validation_viewmodel.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

// Generate mock classes
@GenerateMocks([AuthService])
// TODO: Uncomment after running build_runner
// import 'registration_test.mocks.dart'; // This will be generated by build_runner

class MockAuthService extends Mock implements AuthService {}

void main() {
  group('SignUpPage UI Tests', () {
    testWidgets(
        'SignUpPage has username, email, password fields and signup button',
        (WidgetTester tester) async {
      // Build our app and trigger a frame
      await tester.pumpWidget(
        ProviderScope(
          child: MaterialApp(
            home: SignUpPage(),
          ),
        ),
      );

      // Verify that our UI contains the expected widgets
      expect(find.byType(TextFormField),
          findsAtLeast(4)); // Username, email, and password fields
      
      // Check if the "I agree to the terms and conditions" checkbox is present
      expect(find.byType(Checkbox), findsOneWidget);
      expect(find.text('I agree to the Terms and Conditions'), findsOneWidget);
      expect(find.byType(ElevatedButton), findsWidgets); // Signup button
      expect(find.text('Create Account!'), findsOneWidget);
      // Check if the Go to Login button is present
      expect(find.text('Go to Login'), findsOneWidget);
    });

    testWidgets('SignUpPage navigates to login page when link is tapped',
        (WidgetTester tester) async {
      // Build our app and trigger a frame
      await tester.pumpWidget(
        ProviderScope(
          child: MaterialApp(
            home: SignUpPage(),
          ),
        ),
      );

      // Tap the login link
      await tester.tap(find.text('Go to Login'));
      await tester.pumpAndSettle();

      // Verify navigation (this will depend on your navigation implementation)
      // For example, if you're using named routes:
      // expect(find.byType(LoginPage), findsOneWidget);
    });
  });

  group('Registration Validation Tests', () {
    late AuthValidationViewModel validationViewModel;

    setUp(() {
      validationViewModel = AuthValidationViewModel();
    });

    test('Username validation returns error for empty username', () {
      final result = validationViewModel.validateUsername('');
      expect(result, 'Username cannot be empty');
    });

    test('Username validation returns error for short username', () {
      final result = validationViewModel.validateUsername('usr');
      expect(result, 'Username must be at least 4 characters');
    });

    test('Username validation returns null for valid username', () {
      final result = validationViewModel.validateUsername('testuser');
      expect(result, null);
    });

    test('Email validation returns error for empty email', () {
      final result = validationViewModel.validateEmail('');
      expect(result, 'Email cannot be empty');
    });

    test('Email validation returns error for invalid email format', () {
      final result = validationViewModel.validateEmail('invalid-email');
      expect(result, 'Please enter a valid email');
    });

    test('Email validation returns null for valid email', () {
      final result = validationViewModel.validateEmail('test@example.com');
      expect(result, null);
    });

    test('Password validation returns error for empty password', () {
      final result = validationViewModel.validatePassword('');
      expect(result, 'Password cannot be empty');
    });

    test('Password validation returns error for short password', () {
      final result = validationViewModel.validatePassword('pass');
      expect(result, 'Password must be at least 8 characters');
    });

    test('Password validation returns error for password without uppercase',
        () {
      final result = validationViewModel.validatePassword('password123!');
      expect(result, 'Password must contain at least one uppercase letter');
    });

    test('Password validation returns error for password without lowercase',
        () {
      final result = validationViewModel.validatePassword('PASSWORD123!');
      expect(result, 'Password must contain at least one lowercase letter');
    });

    test('Password validation returns error for password without number', () {
      final result = validationViewModel.validatePassword('Password!');
      expect(result, 'Password must contain at least one number');
    });

    test(
        'Password validation returns error for password without special character',
        () {
      final result = validationViewModel.validatePassword('Password123');
      expect(result, 'Password must contain at least one special character');
    });

    test('Password validation returns null for valid password', () {
      final result = validationViewModel.validatePassword('Password123!');
      expect(result, null);
    });
  });

  group('Registration Authentication Tests', () {
    late MockAuthService mockAuthService;

    setUp(() {
      mockAuthService = MockAuthService();
    });

    test('Register with valid data calls auth service and returns success',
        () async {
      // Arrange
      final username = 'testuser';
      final email = 'test@example.com';
      final password = 'Password123!';
      final code = '123456';

      when(mockAuthService.register(username, email, password, code: code))
          .thenAnswer((_) async => {
                'success': true,
                'user': {
                  '_id': 'user123',
                  'username': username,
                  'email': email
                },
                'message': 'Registration successful'
              });

      // Act
      final result =
          await mockAuthService.register(username, email, password, code: code);

      // Assert
      verify(mockAuthService.register(username, email, password, code: code))
          .called(1);
      expect(result['success'], true);
      expect(result['user']['username'], username);
      expect(result['user']['email'], email);
    });

    test('Register with existing email returns error', () async {
      // Arrange
      final username = 'testuser';
      final email = 'existing@example.com';
      final password = 'Password123!';
      final code = '123456';

      when(mockAuthService.register(username, email, password, code: code))
          .thenAnswer(
              (_) async => {'success': false, 'error': 'Email already exists'});

      // Act
      final result =
          await mockAuthService.register(username, email, password, code: code);

      // Assert
      verify(mockAuthService.register(username, email, password, code: code))
          .called(1);
      expect(result['success'], false);
      expect(result['error'], 'Email already exists');
    });

    test('Send verification code with valid email returns success', () async {
      // Arrange
      final email = 'test@example.com';

      when(mockAuthService.sendVerificationCode(email)).thenAnswer(
          (_) async => {'success': true, 'message': 'Verification code sent'});

      // Act
      final result = await mockAuthService.sendVerificationCode(email);

      // Assert
      verify(mockAuthService.sendVerificationCode(email)).called(1);
      expect(result['success'], true);
    });

    test('Verify code with valid code returns success', () async {
      // Arrange
      final email = 'test@example.com';
      final code = '123456';

      when(mockAuthService.verifyCode(email, code)).thenAnswer(
          (_) async => {'success': true, 'message': 'Code verified'});

      // Act
      final result = await mockAuthService.verifyCode(email, code);

      // Assert
      verify(mockAuthService.verifyCode(email, code)).called(1);
      expect(result['success'], true);
    });

    testWidgets(
        'Registration form submission with valid data calls register service',
        (WidgetTester tester) async {
      // This test would require more complex setup with Provider or Riverpod
      // For now, we'll use a placeholder test
      expect(true, isTrue);
    });
  });
}
